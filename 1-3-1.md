# SS1-3-1 Hello, world 实现

## 行动计划

> 行动名称：Hello, world  
>
> 行动编码：SS1-3  
>
> 行动类别：练习  
>
> 行动目标：输出 "Hello, world"
>
> 行动难度：僵尸  
>
> 行动章节：
> * SS1-3-1
> * SS1-3-2

## 开始行动

### 启动服务器

新建一个 bat 为后缀的文件，输入

~~~ bash
@ehco off
java -server -Xmx2048M -Xms2048M -jar purpur-1.17.1-1385.jar nogui
~~~

再新建一个文件 eula.txt，输入

~~~properties
eula=true
~~~

双击 bat 启动服务器

等启动完成，出现 Done! 等字样就可以关掉了

### 创建项目

打开 IDEA，选择**项目**，点击**新建项目**，选择**Gradle**，**下一步**。名称填**HelloWorld**，位置随你，点开工件坐标，GroupId 填你的域名倒写(a.com就写com.a) + helloworld，如果没有就写"net.mcbbs. + 你的名字"一类的，ArtifactId 填 HelloWorld，版本随便，**完成**.

### 添加依赖

> 参照 https://hub.fastgit.org/pl3xgaming/Purpur/

打开 build.gradle，在 repositories 中添加
~~~
    maven { url 'https://repo.pl3x.net/'}
~~~

在 dependencies 中添加
```
    compileOnly("net.pl3x.purpur:purpur-api:1.17.1-R0.1-SNAPSHOT")
```

?> **发生了什么** ？<br>一个 Java 项目当然不可能是由一个人完成的，你需要编写的代码往往已经有开发者编写过了，这就叫**轮子**(Wheel). 如果你的项目要使用它，就要把它**导入**。导入的**轮子**就叫**依赖**(Dependency).<br>我们添加了 Purpur 的 API，它是 Bukkit API 的一种. <br>而我们用的 Gradle 是一种构建工具，它可以帮助我们方便地构建代码，添加依赖.

### 开始写代码

打开 src/main/java，右击它，**新建**，**软件包**，填上你的刚刚填的 GroupId，再右击这个包，**新建**，**类**，名称填上 `HelloWorld`，IDEA 应该会自动补全代码，像这样：

~~~java
package net.mcbbs.jerryzrf.helloworld;

public class HelloWorld {
}
~~~

接着，我们在 HelloWorld 后面打一个空格，接上 `extends JavaPlugin`，接着再在 HelloWorld 类中间输入：

~~~java
    @Override
    public void onEnable() {
        getLogger().info("Hello, world!");
    }
~~~

现在你的 HelloWorld.java 文件应该类似于这样：

~~~java
package net.mcbbs.jerryzrf.helloworld;

import org.bukkit.plugin.java.JavaPlugin;

public class HelloWorld extends JavaPlugin{
    @Override
    public void onEnable() {
        getLogger().info("Hello, world!");
    }
}
~~~

<hr>

接着，我们右击 **resources**，**新建**，**文件**，填上 `plugin.yml`，然后输入：

~~~yaml
name: HelloWorld
main: net.mcbbs.jerryzrf.helloworld.HelloWorld
version: 1.0
api-version: 1.17
~~~

注意，**main** 这一栏填你的GroupID + HelloWorld

### 我们干了些什么

?> **该部分内容适合新手** <br> 
如果你发现其中内容过于简单，请考虑跳过该部分

我们新建了一个类 HelloWorld，它继承了 JavaPlugin 这个**抽象**(abstract)类，而它就代表着**插件本身**.

我们画出了一张蓝图(类)，把插件的内容写在上面，然后交给了 Bukkit. Bukkit 按照我们的蓝图，建了个房子(对象)，然后开始运行我们的插件.

> 推荐阅读：https://www.runoob.com/java/java-basic-syntax.html 作者：菜鸟教程

现在，我们一行行来解释.

第一行是 `package` 语句
~~~ java
package net.mcbbs.jerryzrf.helloworld;
~~~

什么是语句呢？

从上一个分号开始，到下一个分号为止，是一个语句. 以大括号括起来的部分作为一个整体，和其它部分放在一起，即使后面没有分号，也是一个语句.<br>`int i = 0;` 是一个语句，而<br>
~~~
if (a == b) {
	a++;
	b++;
	System.out.printf("a = b");
}
~~~
也是一个语句.  
而除了以`}`结尾的语句之外，其它每一个语句的最后都有有一个`;`作为结尾.

而后面的`net.mcbbs.jerryzrf.helloworld`，则是包名. 我们只需要知道，包是为了防止名称重复以及方便定位而出现的就行了.
> 推荐阅读：https://www.runoob.com/java/java-package.html 作者：菜鸟教程
<hr>
第二行是 `import` 语句

~~~java
import org.bukkit.plugin.java.JavaPlugin;
~~~

我们之前说了，不可能所以的代码都由你一个人来写，总得有人来造轮子，而我们就可以 import 他们写好的东西.

有句古话说得好：`Import or Input`

<hr>

第三行是类声明

~~~java
public class HelloWorld extends JavaPlugin
~~~

其中 `public`是一个**访问修饰符**，指公开的，意思是大家都可以访问这个类

`class`是类声明的关键字，`HelloWorld`是类名

`extends JavaPlugin`则指继承了`JavaPlugin`这个抽象类，我们就可以用自己的方法实现父类的方法，例如`onEnable`类就是我们自己实现的.

这里就相当于，`JavaPlugin` 是一幅蓝图，已经画好了插件的基本结构，我们把它 Copy 过来，在上面进行一些自定义的修改。我们不用操心插件是怎么被 Bukkit 加载的，因为 `JavaPlugin` 中已经为我们写好了。

> 推荐阅读：https://www.runoob.com/java/java-inheritance.html 作者：菜鸟教程

<hr>

第四行是一个**注解**

~~~java
    @Override
~~~

 @Override 只能标注方法，表示该方法覆盖父类中的方法。

加上这个，我们写的 `onEnable()`函数就可以覆盖掉 JavaPlugin 里的，这样 Bukkit 就会执行我们写的了

要使用重写很简单：

1. 在子类中编写一模一样的方法，访问修饰符要兼容，返回值要一样，名字（标识符）要一样，参数的顺序和类型也要一样.（要覆盖，你要告诉我覆盖哪个方法啊）
2. 在方法的定义的前面，加上 `@Override` 注解，表示这里要重写方法了

> 拓展阅读：https://www.runoob.com/w3cnote/java-annotation.html 作者：skywang12345

<hr>

第五行是一个方法定义

~~~java
    public void onEnable()
~~~

`public`同上，`void`是方法的**返回值**(Return Value)的类型，这里是无返回值的，`onEnable`则是方法名称.

在小括号里的是**参数**(Argument)，参数可以有几个都可以，格式一般为`参数类型 + 参数名`.



